#set text(font: (
  (name: "Arial", covers: "latin-in-cjk"), // 西文字体
  "DengXian" // 中文字体
), lang: "zh")

-1-

大家好, 欢迎来到pkuhub的开发者教程, 我是图班22级的徐靖, 今天是我们总第6次也是我个人给大家开的第二次讲座, 我不知道今天来的有多少同学还记得我在我们第一次讲座的时候我给大家讲git & vscode的使用, 然后用个人网站的部署来作为例子去串联. 

那从git到现在的rust2, rust第二次, 时间上不到两个月, 但知识上的跨度非常大. 如果说git是开发者的入门, 那今天的讲座内容如果大家能掌握了, 其实就已经击败了99%的开发者. 当然这个的前提是掌握, 仅凭我们每次这两个小时是不可能的, 我们尽可能在讲座中去穿插演示和动手实践方便大家理解, 让大家能从这么一个通识性质的讲座中有所收获, 但如果大家想要真正掌握这些东西, 还是需要自己去动手实践, 去写代码, 去做项目, 成为真正的开发者也需要项目的积累. 

-2-

那我们进入正题, 上次由qhw给大家介绍了一些rust的基础知识, 今天我们将继续深入探讨rust的一些高级特性, 包括包管理, 泛型, trait, 生命周期, 以及智能指针. 大家可能对rust这门编程语言包含哪些内容还没有一个整体的认识, 下面我将为大家梳理一下rust的知识体系, 顺带也回顾一下上次讲座的内容.

我让ai把rust的知识体系分为四个部分, 第一个部分语言基础:
- 上次讲了安装与配置, 我们知道rust的安装非常简单, 只需要一个命令就可以完成, 只有windows的可能稍微麻烦一点因为需要vs, 另一方面就是如何使用cargo来管理我们的项目. cargo new新建一个项目, cargo build编译, cargo run运行, cargo test测试, cargo update更新依赖等等. 
- 然后关于变量与可变性, rust的变量默认是不可变的, 这和大多数编程语言不同, 但我们可以使用mut关键字来声明一个可变变量.
- 数据类型与数据结构, rust有很多内置的数据类型和数据结构, 这个今天我讲智能指针的时候还会再整理一次
- 函数, 控制流和方法, rust的函数和方法与其他编程语言类似, 但有一些语法和特性可能听起来没那么常见, 比如闭包和迭代器. 但实际上大家可能不自觉得用过这些东西只是自己意识不到这一点, 比如迭代器python里就有, 这个我们讲座中不涉及, 如果碰到了会简单解释一下
- 所有权系统, rust的核心特性之一, rust通过所有权系统保证所谓的编译时内存安全, 这也是rust与其他编程语言最大的区别之一
第二个部分高级特性:
- 枚举与模式匹配, rust的枚举类型非常强大, 可以用来表示复杂的数据结构, 而模式匹配match关键字则可以方便地对这些数据进行解构和处理
- 错误处理, rust的错误处理机制与其他编程语言不同, 它使用Result和Option两个枚举类型来表示可能的错误和缺失值

之前绿字是上一次讲座的范围, 后面蓝字是我这一期讲座的, 但是实际上这里有一些内容完全可以单独开一次两小时的讲座, 所以我们就只掌握一些核心概念, 那我要写代码我可能了解的要多一点, 或者我可以先写代码看需要什么再学, 那毕竟现在有强大的coding辅助ai, 我们如果能帮助大家看懂代码, 甚至只是知道要去学什么, 那就已经足够了
- 模块与crate包
- 泛型与trait, 这些涉及到rust的类型系统, 可以把他理解成面向对象中模版类和多态在rust中的对应吧. 然后顺带提一下生命周期
- Common Collections的意思其实也是数据结构, rust的标准库提供了一些常用的数据结构, 比如Vec, HashMap, 我们熟悉的字符串String等, 这个我们不会专门讲因为没有多少思想和设计哲学在里面, 但是其实非常常用

- 更进阶的一些内容比如智能指针, 并发编程, 异步编程, 不安全的rust, 这些内容需要大家对内存啊, 数据竞争啊有概念. 但这些都还只是语言本身, 我们想做出来东西, 还需要注意生产级开发中的一些内容, 比如web开发, 嵌入式系统, 甚至是游戏开发, 这些需要我们去了解一些框架和库. 当然我们今天的讲座不会涉及这些内容.

-3-

我们先讲一个简单的内容, 慢慢给大家上难度, 就先从包和模块开始. 包管理的话先给大家介绍几个概念. 到目前为止，我们编写的程序都在一个文件的一个模块中。伴随着项目的增长，你应该通过将代码分解为多个模块和多个文件来组织代码。

一个包（package）可以包含多个二进制 crate 项和一个可选的库 crate。伴随着包的增长，你可以将包中的部分代码提取出来，做成独立的 crate，这些 crate 则作为外部依赖项。对于一个由一系列相互关联的包组成的超大型项目，Cargo 提供了工作空间（workspaces）这一功能

我们也会讨论的实现细节，可以让你在更高层面重用代码：你实现了一个操作后，其他的代码可以通过该代码的公共接口来进行调用，而不需要知道它是如何实现的。你在编写代码时可以定义哪些部分是其他代码可以使用的公共部分，以及哪些部分是你有权更改实现细节的私有部分。这是另一种减少你在脑海中记住项目内容数量的方法。

工作空间我们今天涉及不到, 那关于 Crate 和模块, 大家先记住一件事情, 就是crate是多个模块组成的树结构.

-4- 

第一件事情呢, 我们先看如何用use关键字来引入一个模块. 我们和python对比一下, 在python中加入我们需要一个1到100的随机数, 我们需要import random, 然后就可以在函数体中用random.randint(1, 100)来获取一个随机数. random是标准库自带的, 那假如他不是他是别人写的第三方库, 那我们得先用pip install random来安装这个库, 项目上你还得确定这个库的版本, 规范的做法是有requirements.txt来记录所有的第三方库和版本, 这个我们之前讲git和github的时候都提到过. 

那在rust中这个过程是什么样的呢? 首先代码部分是类似的, use这个关键字和import类似, 那我们先把这几行代码实现一下看看, 也方便后续的演示啊. 
```sh
cargo new example_package
```
复制代码后, 运行
```sh
cd example_package
cargo run
```
你会发现这个有报错, 报错是这个rand包我们没有安装, 那现在我们有两种方法, 一中就类似于python的pip install, 直接在终端中运行
```sh
cargo add rand
```
然后我们再cargo run就没有问题了. 那另一种方式, 我们可以直接在.toml里把这个包添加进去, 他会自动下载. 那这里和python的一个区别是什么, 就是python的环境始终是一个全局环境, 你安装的包是全局的, 而rust的包是和项目绑定的, 也就是说你在一个项目中安装的包不会影响到其他项目. python做到这一点需要用虚拟环境. 

那这个版本号怎么写. 我们先google搜一下这个库, 那这个crates.io就是rust提供的包管理网站, 我们可以在这里搜索到我们需要的包, 那我们可以看到这个包的版本号是0.9.2, 那我们就可以在Cargo.toml中写上. 然后cargo run 的时候会自动下载这些内容然后编译代码然后运行. 

这个就是第三方库的一个使用, 这个大家应该没有问题吧非常简单, 能跟上的扣个1.

-5-

接下来我们看我们自己写的包, 先要弄清楚模块的树结构, 左边这些代码用mod关键字定义模块, 划分了后面这些函数的作用域, 形成的树结构就长右边这样, 这个很直观. 

一个细节就是右边树根的名字crate, 然后main.rs和lib.rs这两个文件是比较特殊, 是rust的约定, 这个不能改.

-6-

我们看下这个模块被定义出来之后怎么用. 

这里我们调用了两次这个函数. 第一次在 eat_at_restaurant 中调用 add_to_waitlist 函数时，使用的是绝对路径。add_to_waitlist 函数与 eat_at_restaurant 被定义在同一 crate 中，这意味着我们可以使用 crate 关键字为起始的绝对路径。接着我们依次包含各级模块，直到我们找到 add_to_waitlist。你可以想象出一个相同结构的文件系统：我们通过指定路径 /front_of_house/hosting/add_to_waitlist 来执行 add_to_waitlist 程序。我们使用 crate 从 crate 根开始就类似于在 shell 中使用 / 从文件系统根开始。

第二次在 eat_at_restaurant 中调用 add_to_waitlist 时，使用的是相对路径。这个路径以 front_of_house 为起始，这个模块在模块树中与 eat_at_restaurant 定义在同一层级。与之等价的文件系统路径就是 front_of_house/hosting/add_to_waitlist。以模块名开头意味着该路径是相对路径。

选择使用相对路径还是绝对路径要取决于你的项目.

然后我们来写一下这个代码, 把这个复制到lib.rs里, 我们先不加pub关键字, 带大家一步步来, 逐步来看他的报错.

错误信息说 hosting 模块是私有的。换句话说，我们拥有 hosting 模块和 add_to_waitlist 函数的正确路径，但是 Rust 不让我们使用，因为它不能访问私有片段。在 Rust 中，所有项（函数、方法、结构体、枚举、模块和常量）默认对父模块都是私有的。如果希望创建一个如函数或结构体的私有项，可以将其放入一个模块。

父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项。这是因为子模块封装并隐藏了它们的实现详情，但是子模块可以看到定义它们的上下文。

-7- 

我们把库定义出来了, 现在我们看怎么在别的地方, 比如main.rs中来用它. 我们复制代码然后运行. 报错是could not find `front_of_house` in the crate root, 这是为什么, 这是因为在lib.rs外部, 这个树根的名字不能叫crate了不然所有的第三方库都是这个名字, 而是应该变成example_package我们的包名. 这是一个容易迷惑的细节, 不过有一点就是你不管是看到crate或者看到example_package, 你就知道这是包的根模块, 是绝对引用, 相对来说还是比较清楚的. 

我们再运行代码, 还是有报错 module `hosting` is not publicly re-exported, 这是因为在lib.rs中我们没有把hosting模块公开, 那我们加上pub关键字就可以了.

我们来总结一下模块的使用, 首先我们可以在lib.rs中定义模块, 然后在别的地方比如main.rs中通过use关键字来引入模块, 这个模块可以是标准库的也可以是第三方库的, 也可以是我们自己写的. 然后我们可以通过pub关键字来公开模块中的函数和结构体等项, 这样其他模块才能访问到这些项.

那use这个操作, 引用相对路径还有两种方式, 分别是super和self关键字。

- super 代表的是父模块为开始的引用方式, 大家自己心里一定要有作用域的概念啊, 我们这里这个函数是在back_of_house内, 所以调用上一层的函数可以用super
- self 代表的是当前模块为开始的引用方式, self这个自己调自己看起来有点无病呻吟, 但是这个其实是有大作用的, 如果我们碰到我们再说, 大家现在只需要知道这个就行了
- 这里这个{}用来多调用几个函数, 还有\*用来引入所有的函数, 这个是语法糖

- focus - 
那现在我们讲了 mod, use, pub, super, self 这五个关键字, 他们支撑起了一个树状的模块系统, 到这里都比较好理解吧, 这是我们今天的第一个阶段成果, 后面还有四个.  我们每到一个阶段成果就做一次总结方便大家回顾和记忆, 大家能跟上的扣个666, 有什么问题也可以现在提.

-8- 

行那我们继续, 我们再上一层到包这个层面, 这张ppt我们上次讲座讲过了, 带大家回顾一下因为这个容易混淆, 因为你用 cargo new 创建的 Package 和它其中包含的包是同名的！

不过，只要你牢记 Package 是一个项目工程，而包只是一个编译单元，也就不会再混淆这两个概念：src/main.rs 和 src/lib.rs 都是编译单元，因此它们都是包。

一种是二进制包，另一种是库包。二进制包的目标是生成可执行文件，而库包的目标是生成可供其他包使用的库。在一个项目中，你可以同时拥有一个二进制包和一个库包。编译之后呢类似于dll动态链接库和exe可执行文件的关系.

-10-

行, 接下来我们讲rust非常核心的一个部分, 就是泛型与特性, 我也会顺带提一下生命周期因为生命周期也是一类泛型. 这部分的地位呢, 就相当于c++中面向对象的编程, 但是他们之间有本质的区别, 不然我们没必要重新弄rust这个语言是吧.

在上难度之前呢, 我先简单介绍一下rust中可能常见的语法糖, 我相信大家不是一两次听我们说"语法糖"这个词了, 可能有同学还不知道这是什么. 语法糖指的是一些简化的语法形式, 使得代码更易读易写, 但在编译后会被转换为更基础的语法. 
例如, rust中的闭包和迭代器就可以看作是语法糖, 使得函数式编程风格在rust中更为自然. rust的泛型, c++的模版类其实功能上也算是语法糖因为可以简化代码嘛, 不过泛型一般不会列在语法糖的列表中, 因为对rust来说这个并不是可有可无的东西, 是非常核心的让rust成为rust的一个部分.

rust中常见的语法糖我罗列了一下, 不知道今天有没有时间来一个一个讲, 我在咱们讲座讲义的github仓库里加了一个罗列这些语法糖写法的文件, 后面如果有时间就带大家熟悉一下, 因为我们最终的目标是让大家能运行代码, 也能看代码知道问ai能问些什么. 这里我们先跳过去讲泛型.

-11-

我们先来看不使用泛型的例子, 这里我们写不同类型的加法, 你会发现这里我们每个类型都要重新写一遍, 而且还不能重复声明, 用的时候得给每个类型分开, 这个就非常麻烦. 泛型可以让我们在编写函数时不需要指定具体的类型，而是使用一个占位符来表示类型，这样就可以在调用函数时传入不同的类型。

你可以把他理解成一种特殊的参数, 包括大一下很多同学程设学模版类的时候也这么理解, 但编译上你不能把他当函数传参看待. Rust 通过在编译时进行泛型代码的所谓单态化（monomorphization）来保证效率。

单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。在这个过程中，编译器所做的工作正好与这个例子中我们创建泛型函数的步骤相反。编译器寻找所有泛型代码被调用的位置并使用泛型代码针对具体类型生成代码。

这样使用泛型没有运行时开销。当代码运行时，它的执行效率就跟好像手写每个具体定义的重复代码一样。换句话说, 当你给函数加一个参数, 他就要对这个参数内部做处理, 但你加一个泛型, 你相当于同时声明了多个函数但不改变函数内部的逻辑. 

我们把这个泛型函数例子放到代码里运行一下, 这里会有报错, 你不能把一个类型T的数据加到另一个T上, 这个报错和trait有关, 我们后面再去解决它.

泛型在c++中的应用最常见的就是模版类, 但在rust中泛型的应用更广泛, 包括函数, 结构体, 枚举等，这样它们就可以用于多种不同的具体数据类型, 这个比c++强太多了.

-12-

我们简单看一下泛型的语法
- 函数
- 结构体
- 枚举
- 方法
再重申一下函数和方法的区别, 函数是独立的, 方法是结构体或枚举的关联函数, 或者说方法是定义在结构体或枚举上的函数, 这个和python的类方法类似, 写方法要在impl块中.

-focus-

现在是阶段成果2, 我们简单了解了泛型的语法和最基础的应用, 以及泛型的编译原理, 这个阶段大家能跟上的扣个2. 到目前为止代码都比较好懂, 后面的就会有一点绕. 之前的有问题也可以现在提.

-13-

我们先看这样一个例子, 先把这段代码复制到vscode里, 这个代码有三个部分
- 这里使用 trait 关键字来声明一个特征，Summary 是特征名。在大括号中定义了该特征的所有方法，在这个例子中是： fn summarize(&self) -> String。

- 特征只定义行为看起来是什么样的，而不定义行为具体是怎么样的。因此，我们只定义特征方法的签名，而不进行实现，此时方法签名结尾是 ;，而不是一个 {}。

- 接下来，每一个实现这个特征的类型都需要具体实现该特征的相应方法，编译器也会确保任何实现 Summary 特征的类型都拥有与这个签名的定义完全一致的 summarize 方法。

- 第二个部分这个结构体很好懂, 我们把他都设置成公有的
- 第三个部分是实现特征, 这里我们使用 impl 关键字来实现特征，impl Summary for Post 表示我们为 Post 类型实现了 Summary 特征。impl 块中定义了特征方法的具体实现。

如果不同的类型具有相同的行为，那么我们就可以定义一个特征，然后为这些类型实现该特征。定义特征是把一些方法组合在一起，目的是定义一个实现某些目标所必需的行为的集合。

例如，我们现在有文章 Post 这种内容载体，我们可以再声明一个微博 Weibo 结构体。现在我们有两个结构体，而我们想对相应的内容进行总结，也就是无论是文章内容，还是微博内容，都可以在某个时间点进行总结，那么总结这个行为就是共享的，因此可以用特征 Summary 来定义. 

说实话，如果特征仅仅如此，你可能会觉得花里胡哨没啥用，接下来我慢慢让大家见识 trait 真正的威力。我们刚刚这个例子通过 trait 以一种抽象的方式定义共同行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。

关于这两类基础用法我简单分了个类,
- trait的声明, 我这个就是声明了一个特征
- trait的实现, 为某个类型实现了这个特征, 这两个这个例子里都有体现
- trait的默认实现, 这个我们就不写代码了, 就是你在声明trait的时候可以给方法一个默认实现, 这样实现这个trait的类型就不需要每个都实现一遍了, 只需要重写不想要的就行. 这个有点类似c++的虚函数.
- trait bounds体现在两个地方, 一个是作用在参数上, 限制泛型的类型必须实现某个特征, 另一个是作用在返回值上, 限制返回值的类型必须实现某个特征. 我们逐个展示

-14-

对于 Trait 在函数中限制类型
- 我们先看第一个实现, 这里的 item 参数，我们指定了 impl 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 notify 函数体中，可以调用任何来自 Summary trait 的方法，比如 summarize。我们可以传递任何 Weibo 或者 Post 的实例来调用 notify。任何用其它如 String 或 i32 的类型调用该函数的代码都不能编译，因为它们没有实现 Summary。
- 这种写法与上一个示例等价，但更为冗长。trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面。
- 然后这我们也可以指定多个 trait bound。假设我们希望 some_function 在 t 上既能使用格式化显示，又能使用被copy的行为，那么我们可以使用 + 来指定多个 trait bound。
- 然后这里还有个语法糖, 叫做where子句, 这个可以让我们把 trait bound 放到函数签名的末尾, 这样可以让函数签名更清晰, 但实际上编译器会把它转换为上面的形式。

-15-

然后对于 Trait 在方法中限制类型呢, 这个初学者看起来有点绕, 这里如果你把这个trait去掉呢, 那我左边这个Pair就是一个正常的泛型结构体对吧, 然后下面就是为这个泛型结构体实现的一个方法, 那我现在为这个加上Trait, 那么这个方法可以接受任何类型的参数, 只要这个类型实现了我指定的trait就行.

还有一个比较好玩的点, 就是可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 blanket implementations，它们被广泛的用于 Rust 标准库中。例如，标准库为任何实现了 Display trait 的类型实现了 ToString trait。这个 impl 块看起来像这样：

我稍微解释一下这两个trait的功能, display trait是为类型实现用户友好的文本表示（如打印日志、命令行输出）, 而 ToString trait 则是为类型实现将其转换为 String 的方法。ToString trait 的实现依赖于 Display trait，因为 ToString trait 的实现会调用 Display trait 的方法来生成字符串表示。这里就有点类似c++继承的, 不同在于c++是对象的继承, 而rust是trait的继承.

-16-

通过使用 impl Summary 作为返回值类型，我们指定了 returns_summarizable 函数返回某个实现了 Summary trait 的类型，但是不确定其具体的类型。在这个例子中 returns_summarizable 返回了一个 Weibo，不过调用方并不知情。

但是这种方式有一个缺陷, 就是这只适用于返回单一类型的情况。例如，这段代码的返回值类型指定为返回 impl Summary，什么意思呢, 就是这里返回一个Weibo对象是吧, 如果你把他改成if else分支, if 怎么怎么样就反回Weibo对象, else就返回Post对象, 那么这个函数就不能编译了, 因为返回值类型不一致. 这时候我们就需要用到一个叫动态分发的技术, 还有个名词叫trait对象。这里我们不再继续深入下去了因为短时间大家接受不了那么多东西, 同学们如果碰到了可以自己去了解。

-focus-
我们再简单回顾一下trait的用法, 现在我们已经掌握了trait的声明, trait的实现, trait的默认实现, trait bounds 在函数, 方法中的使用. 

如果c++学到这里呢面向对象已经到一半了, 但是rust这边才刚刚开始, 以上介绍的内容只是 trait 的冰山一角. Rust是有学习门槛的现代化编程语言, 这个某种意义上只适合学历高的同学来学, 普通人学rust没什么用. 大家的同龄人呢, 这个时候可能在学相对简单明快, 缺陷也多的java或者go作为后端的语言, 但是你看我们学校里面平时大家写的高级编程语言除了python, c++好像就是信科有部分同学在写rust.

-17-

我们来看个例子, 这个泛型函数我们刚刚声明了一次, 但没有写实现. 这个函数目的就是求最大值, 传入一个数组切片, 传出一个数据, 数据的类型是泛型T. 然后如果去运行的话会有报错, 我们最开始那个a+b的函数也有报错我们当时没解决, 和这个是同一种问题.

这个报错是因为在 largest 函数体中我们想要使用大于运算符（>）比较两个 T 类型的值。这个运算符是标准库中特征 std::cmp::PartialOrd 的一个默认方法。所以需要在 T 的特征约束中指定 PartialOrd，这样 largest 函数可以用于内部元素类型可比较大小的数组切片。

由于 PartialOrd 在标准库中, 不需要手动将其引入作用域。所以可以将 largest 的签名修改为如下, 就能解决这个问题

这个例子就是rust的静态分派技术

-18-

讲到这里呢, 我不知道大家心里有没有把trait和c++或者python的面向对象做一个对比. 我们先假设我们是语言设计者, 我们思考一下面向对象这件事情, 需要让一门语言具备哪些特性?

基础的特性包含四个, 封装, 抽象, 继承和多态
封装 (Encapsulation) & 抽象 (Abstraction)

封装是指将数据和操作数据的代码封装在一起, 使得外部代码无法直接访问内部实现细节. 抽象是指通过公共接口隐藏内部实现细节, 只暴露必要的功能. 抽象是封装的一个必然结果啊. 

C++ 方式： 使用 class 关键字。成员变量和成员函数封装在类定义中。通过 private、protected、public 访问修饰符控制可见性。公共接口暴露方法，隐藏内部实现细节（抽象）。

Rust 方式：
struct 或 enum： 定义数据结构。默认所有字段和方法都是私有的（private）。
impl 块： 在 impl 块中为 struct 或 enum 定义方法（包括关联函数）。
pub 关键字： 这是 Rust 控制可见性的核心。你可以将整个 struct/enum、特定的字段、特定的方法/关联函数标记为 pub (public)。

继承 (Inheritance) C++ 方式： 使用 : public BaseClass 语法实现类之间的继承。子类自动获得父类的成员变量和方法（根据访问权限），并可以添加或覆盖（override）方法。

Rust 方式：
没有传统类继承！ Rust 明确没有类之间的继承机制。你不能让一个 struct 继承另一个 struct 的字段或方法实现。
替代方案：
Trait 默认实现： Trait 可以为其定义的方法提供默认实现。当某个类型实现该 trait 时，如果它不提供自己的实现，就会使用这个默认实现。这提供了一种代码复用机制，类似于接口的“默认方法”，但不继承状态（字段）。

组合 (Composition)： 这是 Rust 中实现代码和状态复用的主要方式。一个 struct 可以将另一个 struct 的实例作为其字段成员（has-a 关系）。然后可以定义方法，委托（delegate）给内部成员的方法，或者提供自己的包装逻辑。这比继承更灵活、更不易出错（避免了“脆弱的基类”问题）。

脆弱的基类问题是指在继承体系中，父类的修改可能会破坏子类的行为，导致难以追踪的错误。Rust 的组合方式避免了这种问题，因为子类不会直接依赖父类的实现细节。

Trait 继承： Trait 本身可以使用 trait SubTrait: SuperTrait { ... } 的语法“继承”其他 trait。这意味着要实现 SubTrait 的类型，必须同时实现 SuperTrait。这主要用于约束和接口扩展，定义更具体的 trait 需要满足更基础的 trait 要求，同样不涉及状态继承。

说这些可能比较抽象, 我打个比方, 我们假设有一个动物类, 那么我们可以有一个哺乳动物类继承动物类, 然后有一个猫类继承哺乳动物类, 这样猫就拥有了动物和哺乳动物的所有属性和方法, 这是c++的做法. 这个系统感觉很直观很自然, 但是有一些问题, 一个就是之前说的脆弱基类, 假如我们的生物学界对哺乳动物的定义有了新的发现, 那么我们是不是从上到下所有的哺乳动物的函数都要修改. 另一个呢, 比如某种人他不是猫, 但他有猫的行为, 那么我们是不是要定义一个新的类, 还是说让这个猫娘类继承猫类呢? 后一种方式很别扭因为他不是猫他是人, 而且同时又有脆弱基类问题, 如果我们对猫的理解发生变化, 猫娘不能跟着改吧. 但前一种方式你又需要把猫的所有函数都重写一遍.

但在rust中, Rust的设计哲学是：“组合优于继承”（Composition over Inheritance），“行为分离于数据”（Behavior is separate from Data）。trait这个东西在定义的不依赖于你的数据结构, 然后你要创造一个实例, 就可以把猫的trait和人类的trait组合在一起, 这样就可以实现猫娘的行为, 而且如果我们对猫的理解发生变化, 我们只需要修改猫的trait, 而不需要修改猫娘的trait. 这就是rust的"继承". 可以让你精准且优美地定义猫娘. 

另一方面呢, 基于trait的组合的本质是一个概念, 叫做鸭子类型. 这是动态类型语言的概念，简单来说，就是只关心值长啥样，而不关心它实际是什么。当一个东西走起来像鸭子，叫起来像鸭子，那么它就是一只鸭子，就算它实际上是一个奥特曼，也不重要，我们就当它是鸭子。 我们之前也看到了 Rust 的 trait 机制允许你定义一个类型的行为，而不关心它的具体实现细节。只要一个类型实现了某个 trait，它就可以被当作该 trait 的实例来使用。

多态 (Polymorphism)C++ 方式： 主要通过虚函数 (virtual) 和继承实现运行时多态（动态分派）。基类指针或引用指向子类对象，调用虚函数时执行实际对象类型的方法。

Rust 方式： Trait 是 Rust 实现多态的核心机制. 编译时多态(静态分派) : 泛型函数和特征 bounds. 运行时多态(动态分派) : 特征对象（dyn Trait） 我们还是用一个例子来说明它要做什么, 静态分派就是我让这个函数可以接受任何实现了特定 trait 的类型作为参数. 这个我们讲的比较清楚了. 动态分派就是我让这个函数可以接受任何实现了特定 trait 的类型作为返回值, 但不确定具体的类型. 我们之前有个weibo作为返回的例子, 他如果写成if else分支, 要么返回微博类型要么返回post类型, 那么这个函数就不能编译了, 这时候我们就需要用到动态分派的技术.

我这里解释了一下动态类型语言是什么, 因为rust做到了动态类型语言能做到的事, 但实际上呢, Rust 是一门强类型、静态类型的语言。所有类型在编译时就必须确定。我们讨论的运行时多态（动态分派）仅仅是指方法调用的具体实现在运行时确定，而对象本身的类型信息在编译时仍然是已知的（只是通过特征对象进行了抽象）。这与 Python、JavaScript 等真正的动态类型语言（变量类型在运行时可以改变，方法解析完全在运行时进行）有本质区别。

-19-

接下来我们来看看生命周期, 我把生命周期这个看起来和泛型和trait不在同一个层面的东西放一起呢, 是因为生命周期也是一类泛型。不同于确保类型有期望的行为，生命周期用于保证引用在我们需要的整个期间内都是有效的。

生命周期注解甚至不是一个大部分语言都有的概念，所以这可能感觉起来有些陌生。rust的生命周期是博大精深的, 但我们今天只需给大家展示一些常见用法, 让大家心里能有一个概念. 

生命周期的主要目标是避免悬垂引用（dangling references），后者会导致程序引用了非预期引用的数据。我们看下面这个程序，它有一个外部作用域和一个内部作用域. 

外部作用域声明了一个没有初值的变量 r，而内部作用域声明了一个初值为 5 的变量 x。在内部作用域中，我们尝试将 r 的值设置为一个 x 的引用。接着在内部作用域结束后，尝试打印出 r 的值。这段代码不能编译因为 r 引用的值在尝试使用之前就离开了作用域。

-20-

我们给相同例子加上变量生命周期的注释. 这里将 r 的生命周期标记为 'a 并将 x 的生命周期标记为 'b。如你所见，内部的 'b 块要比外部的生命周期 'a 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 r 拥有生命周期 'a，不过它引用了一个拥有生命周期 'b 的对象。程序被拒绝编译，因为生命周期 'b 比生命周期 'a 要小：被引用的对象比它的引用者存在的时间更短。

我们再看正确的例子. 右边这个这里 x 拥有生命周期 'b，比 'a 要大。这就意味着 r 可以引用 x：Rust 知道 r 中的引用在 x 有效的时候也总是有效的。

我们上次讲座有一个细节：Rust 中的每一个引用都有其生命周期（lifetime），也就是引用保持有效的作用域。大部分时候生命周期就像我们这两个例子一样, 是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明它们的关系，这样就能确保运行时实际使用的引用绝对是有效的。

-21-

我们对比这两个需要显示注明的例子. 现在函数签名表明对于某些生命周期 'a，函数会获取两个参数，它们都是与生命周期 'a 存在的至少一样长的字符串 slice。函数会返回一个同样也与生命周期 'a 存在的至少一样长的字符串 slice。它的实际含义是 longest 函数返回的引用的生命周期与函数参数所引用的值的生命周期的较小者一致。这个关系就是我们希望 Rust 分析代码时所使用的。

记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意 longest 函数并不需要知道 x 和 y 具体会存在多久，而只需要知道有某个可以被 'a 替代的作用域将会满足这个签名。这个有一点点模式匹配的感觉.

这些注解出现在函数签名中，而不存在于函数体中的任何代码中。生命周期注解成为了函数约定的一部分，非常像签名中的类型。让函数签名包含生命周期约定意味着 Rust 编译器的工作变得更简单了。如果函数注解有误或者调用方法不对，编译器错误可以更准确地指出代码和限制的部分。实际写代码的时候, 如果不这么做的，Rust 编译会对我们期望的生命周期关系做更多的推断，这样编译器可能只能指出离出问题地方很多步之外的代码。这是一个小经验

当具体的引用被传递给 longest 时，被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。然后我们用相同的生命周期参数 'a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。

-focus-

这是第四个阶段成果, 直接我们讲了rust的面向对象的设计以及生命周期注解的一些逻辑. 我们已经讲了今天讲座4/5的内容, 如果今天讲座上的rust设计哲学和语言特性你能掌握90%, 这可能需要很多个小时的时间, 和别人说起rust这门语言的时候, 你也能有一些insight. 呃我说直白一点, 就是这个水平可以在简历加一个掌握rust语言了. 

此外呢, 你读相对复杂一些的rust代码就不会有那种一点看不懂的感觉. 因为我们学python的时候可能大家都听说过一个说法, 如果你会了c++, python是不需要学的, 直接就能看懂代码在干什么, 就没有语言学习的门槛. 但rust有门槛, 这个rust上是做不到的, 不经过一段时间的学习, 直接给你一段rust源码, 那些关键字声明啊实现啊一定是看不懂的, 更别说写出来过编译的代码的. 

但是这里有个好处是什么呢, 虽然大家短期不太可能体会到rust的优势, 就是你rust的代码只要过编译了, 那你的代码即便是在生产环境, 大家知道开发分开发环境和生产环境, 像python你自信满满写的代码, 在开发环境在本地也跑通了, 上服务器一部署一堆莫名奇妙报错. 而rust在绝大多数场景下回避这一点, 即便在生产环境也很难出错, 他是一个督促程序员写出高质量代码, 做到编译即运行的语言. 这也是为什么rust在一些大型项目中被广泛使用的原因, 比如说火狐浏览器的渲染引擎就是用rust写的, 还有一些区块链项目也在用rust.

到这里大家能跟上吗, 能跟上扣个4. 

-23-
最后我们讲讲rust的智能指针, 讲这个之前我们再来一点rust的整体理解, 我把rust中所有的数据类型呢分了四个类, 虽然本质上是三个类
- 首先是基础类型, 包括不同精度的有符号整数, 无符号整数, 浮点数, 布尔值和字符, 还有isize和usize这个和指针大小一致的整数类型, 还有非0整数和非0无符号整数
- 然后是复合类型, 包括元组和数组以及切片, 这个和python的区别是元组默认是不可变的, 数组是固定长度的, 切片是动态长度的. 声明就长这样啊
- 然后是一些经典的数据结构, 包括vector, string, hash map, 这些内容大家学数算就自然懂了
- 最后是智能指针, 这个是rust的一个特色, 也是我们今天的重点. 智能指针是一个数据结构, 它不仅包含数据本身, 还包含一些元数据, 比如引用计数, 生命周期等. 实际上上面这些数据结构也算是智能指针, 但我们这里罗列的一些有rust的特殊的实现, 而非数据结构这类纯抽象的东西. 我们后面只讲Box这一个最基础的智能指针. 

-24-
我们先说指针, 指针（pointer）是一个包含内存地址的变量的通用概念。这个地址引用，或 “指向”（points at）一些其它数据。Rust 中最常见的指针是就是引用（reference）。引用以 & 符号为标志并借用了它们所指向的值。除了引用数据没有任何其他特殊功能，也没有额外开销。

另一方面，智能指针（smart pointers）是一类数据结构，它们的表现类似指针，但是也拥有额外的元数据和功能。这个概念并不为 Rust 所独有；其起源于 C++ 并存在于其它语言中。

Rust 标准库中定义了多种不同的智能指针，它们提供了多于引用的额外功能。在 Rust 中因为引用和借用的概念，普通引用和智能指针有一个额外的区别：引用是一类只借用数据的指针，在大部分情况下，智能指针拥有它们指向的数据。

因为智能指针是一个在 Rust 经常被使用的通用设计模式, 这是一个你可能自己意识不到但你确实在使用的概念. 你可能在rust讲智能指针的教程里只能看到我们之前罗列的那些, 但实际上你在使用的很多数据结构和类型都可以被视为智能指针。

智能指针通常使用结构体实现。智能指针不同于结构体的地方在于其实现了 Deref 和 Drop trait。Deref trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。Drop trait 允许我们自定义当智能指针离开作用域时运行的代码。后面我们会看到例子

-25-

最简单直接的智能指针是 Box<T>。box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。

除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景：

- 第一种场景, 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候, 我们待会展示这个场景
- 第二种场景, 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候. 这种情况中，转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上。接着，只有少量的指针数据在栈上被拷贝。这个我们就不展示怎么写了.
- 第三种场景, 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候, 这种情况也是trait对象, 今天我们不讲

以上就是一种用法三种场景总共四个用法

第一个就是左下角这个, 直接放一个值放到堆上, 这个是最简单的用法, 我们直接把一个i32类型的值放到堆上, 然后通过Box::new函数来创建一个Box<i32>类型的智能指针.

第二个是我们展示的所谓递归类型的场景, 就是你List这个枚举对吧, 在里面又用了一次, 这个东西你是不知道它的大小的, 因为你不知道它什么时候会停止调用.

-26-

更形象地说明这个事情, 我们看下面这两个例子

Rust 编译器检查像左边的 List 这样的递归类型时会发生什么呢。编译器从这个枚举的 Cons 变体开始分析，其需要的空间等于 i32 的大小加上 List 的大小。为了计算 List 需要多少内存，编译器检查其变体，从 Cons 变体开始。Cons 变体储存了一个 i32 值和一个List值，这样的计算将无限进行下去

然后右边的例子是能过编译的例子, Cons 变体将会需要一个 i32 的大小加上储存 box 指针数据的空间。Nil 变体不储存值，所以它比 Cons 变体需要更少的空间。现在我们知道了任何 List 值最多需要一个 i32 加上 box 指针数据的大小。通过使用 box，打破了这无限递归的连锁，这样编译器就能够计算出储存 List 值需要的大小了

box 只提供了间接存储和堆分配；它们并没有任何其他特殊的功能，其他智能指针也没有特殊功能带来的性能损失，所以它们可以用于像 cons list 这样间接存储是唯一所需特性的场景。当然用法和场景远不止这一个

那这里的智能指针相比于c++的优势在哪呢, Box<T> 类型是一个智能指针，因为它实现了 Deref trait，它允许 Box<T> 值被当作引用对待。另一方面当 Box<T> 值离开作用域时，由于 Box<T> 类型 Drop trait 的实现，box 所指向的堆数据也会被清除。c++想实现这样的功能需要手动管理内存，而 Rust 的智能指针通过所有权系统和借用检查器自动处理内存管理。

-27-
我们再看最后一个例子, 我们用box这个智能指针来实现二叉树, 主流的有三种写法:
- 首先是枚举方式, 通过定义一个枚举类型来表示二叉树的节点, 每个节点包含一个值和指向左右子树的指针.这个比较直观对吧, 然后如果是空节点就是empty这个变体
- 第二种方式是用了Option这个枚举类型的方法, 通过将左右子树的指针类型定义为`Option<Box<TreeNode<T>>>`，这样就可以表示空节点了。这个Option枚举我说明一下, 它是错误处理的一个常用方式, 它有两个变体 Some(T) 和 None, 分别表示有值和无值. 这个在rust中非常常见, 你可以把它理解成一个可选类型, 也就是可能有值也可能没有值.
- 最后一种方式我们不讲了, 这个是使用Rc 和 RefCell这两个智能指针的方式, 它可以实现共享所有权和可变性, 但这个比较复杂.

可能有同学要问啊, 这三种二叉树的实现看起来都比c++复杂, c++我这里都不需要指针, 直接用一个类就能实现二叉树了, 那么我为什么这里要说rust有优势呢? 原因是rust的实现是内存安全的, 我现在让ai帮我们写一个c++的内存安全的二叉树,看看有多复杂啊. c++要做到这一点也需要用智能指针.

-focus-

我们的讲座内容到这里就结束了, 我们今天讲了rust的包管理, 泛型, trait, 生命周期, 智能指针五大块的内容, 中间穿插了一些整体认识, 比如rust的语法糖, 数据类型, 还有rust的面向对象设计. 大家感觉自己接受的怎么样啊, 对这些都能有个简单印象的可以扣个666, 让我看看大家的反馈.

现在是答疑环节, 之前ppt上的问题大家可以提一提, 我把ppt发群里.